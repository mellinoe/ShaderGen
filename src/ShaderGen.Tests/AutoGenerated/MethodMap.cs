using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Xunit;

namespace ShaderGen.Tests.AutoGenerated
{
    /// <summary>
    /// Holds information about the mapping of a tested method parameterFields and return to a buffer.
    /// </summary>
    internal class MethodMap
    {
        /// <summary>
        /// The owner mappings.
        /// </summary>
        public readonly Mappings Mappings;

        /// <summary>
        /// The index of the method.
        /// </summary>
        public readonly int Index;

        /// <summary>
        /// The method info.
        /// </summary>
        public readonly MethodInfo Method;

        /// <summary>
        /// The parameter to field map.
        /// </summary>
        public readonly IReadOnlyDictionary<ParameterInfo, PaddedStructCreator.Field> ParameterFields;

        /// <summary>
        /// The field that holds the return value if any; otherwise <see langword="null"/>.
        /// </summary>
        public readonly PaddedStructCreator.Field ResultField;

        /// <summary>
        /// The offset into the result set where the result can be found; or -1 to indicate no result.
        /// </summary>
        public readonly int ResultSetOffset;

        /// <summary>
        /// Initializes a new instance of the <see cref="MethodMap" /> class.
        /// </summary>
        /// <param name="mappings">The mappings.</param>
        /// <param name="index">The index.</param>
        /// <param name="method">The method.</param>
        /// <param name="parameterFields">The parameterFields.</param>
        /// <param name="resultField">The return field.</param>
        /// <param name="resultSetOffset">The result set offset.</param>
        public MethodMap(Mappings mappings, int index, MethodInfo method, IReadOnlyDictionary<ParameterInfo, PaddedStructCreator.Field> parameterFields, PaddedStructCreator.Field resultField, int resultSetOffset)
        {
            Mappings = mappings;
            Index = index;
            Method = method;
            ParameterFields = parameterFields;
            ResultField = resultField;
            ResultSetOffset = resultField == null ? -1 : resultSetOffset;
            Signature =
                $"{method.ReturnType.Name} {method.DeclaringType.FullName}.{method.Name}({String.Join(", ", ParameterFields.Select(p => $"{p.Key.ParameterType.Name} {p.Key.Name}"))})";
        }

        /// <summary>
        /// Gets the signature.
        /// </summary>
        /// <value>
        /// The signature.
        /// </value>
        public string Signature { get; }

        /// <summary>
        /// Calculates the offset of a specific field in the test data buffer for this method.
        /// </summary>
        /// <param name="field">The field.</param>
        /// <param name="test">The test.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private int FieldOffset(PaddedStructCreator.Field field, int test) =>
            test * Mappings.BufferSize + Index * Mappings.StructSize + field.Position;

        /// <summary>
        /// Generates test data for this method, executes it and stores the result.
        /// </summary>
        /// <param name="testData">The test data.</param>
        /// <param name="test">The test.</param>
        public void GenerateTestData(byte[] testData, int test)
        {
            // TODO I suspect this can all be done a lot easier with Span<T> once upgraded to .Net Core 2.1
            // Create random input values
            foreach (PaddedStructCreator.Field field in ParameterFields.Values)
            {
                int floatCount = (int)Math.Ceiling(
                    (float)Math.Max(field.AlignmentInfo.ShaderSize, field.AlignmentInfo.CSharpSize) /
                    sizeof(float));

                // Get random floats to fill parameter structure
                float[] floats = TestUtil.GetRandomFloats(floatCount);
                GCHandle handle = GCHandle.Alloc(floats, GCHandleType.Pinned);
                try
                {
                    // Fill test data
                    IntPtr ptr = Marshal.UnsafeAddrOfPinnedArrayElement(testData, FieldOffset(field, test));
                    Marshal.Copy(floats, 0, ptr, floats.Length);
                }
                finally
                {
                    handle.Free();
                }
            }
        }

        /// <summary>
        /// Gets the parameters for this method from the test data.
        /// </summary>
        /// <param name="testData">The test data.</param>
        /// <param name="test">The test.</param>
        /// <returns></returns>
        public object[] GetParameters(byte[] testData, int test)
        {
            // TODO I suspect this can all be done a lot easier with Span<T> once upgraded to .Net Core 2.1

            // Grab test data
            object[] parameters = new object[ParameterFields.Count];
            GCHandle handle = GCHandle.Alloc(testData, GCHandleType.Pinned);
            try
            {
                foreach (KeyValuePair<ParameterInfo, PaddedStructCreator.Field> kvp in ParameterFields)
                {
                    ParameterInfo pInfo = kvp.Key;
                    PaddedStructCreator.Field field = kvp.Value;

                    // Create object of correct type
                    IntPtr ptr = Marshal.AllocCoTaskMem(field.AlignmentInfo.CSharpSize);
                    Marshal.Copy(
                        testData,
                        FieldOffset(field, test),
                        ptr,
                        field.AlignmentInfo.CSharpSize);

                    // Assign parameter
                    parameters[pInfo.Position] = Marshal.PtrToStructure(ptr, field.Type);
                }

                return parameters;
            }
            finally
            {
                handle.Free();
            }
        }

        /// <summary>
        /// Copies the result from test data to the result set.
        /// </summary>
        /// <param name="testData">The test data.</param>
        /// <param name="results"></param>
        /// <param name="test">The test.</param>
        /// <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetResult(IntPtr testData, byte[] results, int test)
        {
            Marshal.Copy(
                // GPU test data is always a single test
                testData + Index * Mappings.StructSize + ResultField.Position,
                results,
                test * Mappings.ResultSetSize + ResultSetOffset,
                ResultField.AlignmentInfo.ShaderSize);
        }

        /// <summary>
        /// Gets the result from the result set.
        /// </summary>
        /// <param name="results">The results.</param>
        /// <param name="test">The test.</param>
        /// <returns></returns>
        public object GetResult(byte[] results, int test)
        {
            GCHandle handle = GCHandle.Alloc(results, GCHandleType.Pinned);
            try
            {
                // Create object of correct type
                IntPtr ptr = Marshal.AllocCoTaskMem(ResultField.AlignmentInfo.CSharpSize);
                Marshal.Copy(results, test * Mappings.ResultSetSize + ResultSetOffset, ptr, ResultField.AlignmentInfo.CSharpSize);

                // Return structure
                return Marshal.PtrToStructure(ptr, ResultField.Type);
            }
            finally
            {
                handle.Free();
            }
        }

        /// <summary>
        /// Generates test data for this method, executes it and stores the result.
        /// </summary>
        /// <param name="testData">The test data.</param>
        /// <param name="results">The results.</param>
        /// <param name="test">The test.</param>
        public void ExecuteCPU(byte[] testData, byte[] results, int test)
        {
            object result = Method.Invoke(null, GetParameters(testData, test));

            if (ResultField == null)
            {
                Assert.Null(result);
                return;
            }

            // Copy result into result set
            GCHandle handle = GCHandle.Alloc(result, GCHandleType.Pinned);
            try
            {
                // Copy result data
                Marshal.Copy(handle.AddrOfPinnedObject(), results, test * Mappings.ResultSetSize + ResultSetOffset, ResultField.AlignmentInfo.ShaderSize);
            }
            finally
            {
                handle.Free();
            }
        }

        /// <summary>
        /// Returns a <see cref="System.String" /> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String" /> that represents this instance.
        /// </returns>
        public override string ToString() => $"Mappings for {Signature} [{Index}]";
    }
}