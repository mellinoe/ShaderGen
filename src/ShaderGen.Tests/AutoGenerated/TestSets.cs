using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using ShaderGen.Tests.Tools;

namespace ShaderGen.Tests.AutoGenerated
{
    /// <summary>
    /// 
    /// </summary>
    /// <seealso cref="TestSet" />
    internal class TestSets : IReadOnlyList<TestSet>
    {
        /// <summary>
        /// The compilation.
        /// </summary>
        public readonly Compilation Compilation;

        /// <summary>
        /// The mappings.
        /// </summary>
        public readonly Mappings Mappings;

        /// <summary>
        /// The test data used for these test sets.
        /// </summary>
        public readonly byte[] TestData;

        /// <summary>
        /// The number of test iterations.
        /// </summary>
        public readonly int TestLoops;

        /// <summary>
        /// The sets.
        /// </summary>
        private IReadOnlyList<TestSet> _sets;

        /// <summary>
        /// The minimum mantissa of generated floats.
        /// </summary>
        public readonly int MinMantissa;

        /// <summary>
        /// The maximum mantissa of generated floats.
        /// </summary>
        public readonly int MaxMantissa;

        /// <summary>
        /// Initializes a new instance of the <see cref="TestSets" /> class.
        /// </summary>
        /// <param name="toolChains">The tool chains.</param>
        /// <param name="compilation">The compilation.</param>
        /// <param name="mappings">The mappings.</param>
        /// <param name="testLoops">The test loops.</param>
        /// <param name="minMantissa">The minimum mantissa.</param>
        /// <param name="maxMantissa">The maximum mantissa.</param>
        public TestSets(IEnumerable<ToolChain> toolChains, Compilation compilation, Mappings mappings, int testLoops, int minMantissa, int maxMantissa)
        {
            Compilation = compilation;
            Mappings = mappings;
            TestLoops = testLoops;
            MinMantissa = minMantissa;
            MaxMantissa = maxMantissa;

            TestData = new byte[mappings.BufferSize * testLoops];

            // Create a set for the CPU and then sets for each tool chain.
            _sets = new[]
                    {new TestSet(this)}
                .Concat(toolChains.Select(tc => new TestSet(this, tc)))
                .ToArray();

            // Generate the test data and the result set data for the CPU.
            TestData = new byte[mappings.BufferSize * testLoops];
            for (int test = 0; test < testLoops; test++)
            {
                foreach (MethodMap method in mappings.MethodMaps)
                {
                    method.GenerateTestData(TestData, test, minMantissa, maxMantissa);
                }
            }
        }

        /// <summary>
        /// Gets the failures.
        /// </summary>
        /// <returns></returns>
        public IReadOnlyDictionary<MethodMap, IReadOnlyList<Failure>> GetFailures(float epsilon = float.Epsilon)
        {
            Dictionary<MethodMap, IReadOnlyList<Failure>> dictionary = new Dictionary<MethodMap, IReadOnlyList<Failure>>();
            List<Failure> failures = new List<Failure>();
            FloatComparer comparer = new FloatComparer(epsilon);
            // Get pointer array
            foreach (MethodMap method in Mappings.MethodMaps)
            {
                if (method.ResultField == null)
                {
                    // This method has no results, so just skip it
                    continue;
                }

                for (int test = 0; test < TestLoops; test++)
                {
                    // Calculate more detailed failure analysis
                    Failure failure = Failure.Test(this, method, test, comparer);
                    if (failure != null)
                    {
                        failures.Add(failure);
                    }
                }

                if (!failures.Any())
                {
                    continue;
                }

                dictionary[method] = failures.ToArray();
                failures.Clear();
            }

            return dictionary;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// An enumerator that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<TestSet> GetEnumerator() => _sets.GetEnumerator();

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
        /// </returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Gets the number of elements in the collection.
        /// </summary>
        public int Count => _sets.Count;

        /// <summary>
        /// Gets the <see cref="TestSet"/> at the specified index.
        /// </summary>
        /// <value>
        /// The <see cref="TestSet"/>.
        /// </value>
        /// <param name="index">The index.</param>
        /// <returns></returns>
        public TestSet this[int index] => _sets[index];


    }
}
